# Code Coverage Analysis Workflow
# This workflow runs comprehensive test coverage analysis and reports

name: Code Coverage

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    # Run coverage analysis weekly on Sundays at 6 AM UTC
    - cron: '0 6 * * 0'
  workflow_dispatch:

env:
  PYTHON_VERSION: '3.12'
  COVERAGE_THRESHOLD: 70
  COVERAGE_FAIL_UNDER: 60

jobs:
  coverage-analysis:
    name: Coverage Analysis
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better coverage tracking

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Run comprehensive test coverage
        run: |
          # Run with detailed coverage
          python -m pytest \
            --cov=string_multitool \
            --cov=String_Multitool \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term-missing \
            --cov-report=json \
            --cov-config=pyproject.toml \
            --cov-fail-under=${{ env.COVERAGE_FAIL_UNDER }} \
            --junit-xml=coverage-junit.xml \
            --verbose \
            test_transform.py test_hotkey.py test_hotkey_integration.py

      - name: Generate coverage badge
        run: |
          pip install coverage-badge
          coverage-badge -o coverage-badge.svg

      - name: Generate coverage report summary
        run: |
          python -c "
          import json
          import xml.etree.ElementTree as ET
          
          # Parse XML coverage report
          tree = ET.parse('coverage.xml')
          root = tree.getroot()
          
          # Get overall coverage
          line_rate = float(root.attrib['line-rate']) * 100
          branch_rate = float(root.attrib['branch-rate']) * 100
          
          print(f'## Coverage Report Summary')
          print(f'')
          print(f'- **Line Coverage**: {line_rate:.1f}%')
          print(f'- **Branch Coverage**: {branch_rate:.1f}%')
          print(f'- **Threshold**: {int('${{ env.COVERAGE_THRESHOLD }}')}%')
          print(f'')
          
          # Status
          if line_rate >= ${{ env.COVERAGE_THRESHOLD }}:
              print('‚úÖ **Status**: Coverage meets threshold')
          elif line_rate >= ${{ env.COVERAGE_FAIL_UNDER }}:
              print('‚ö†Ô∏è **Status**: Coverage below target but above minimum')
          else:
              print('‚ùå **Status**: Coverage below minimum threshold')
          
          print(f'')
          print(f'### Coverage by Module')
          print(f'')
          print(f'| Module | Lines | Coverage |')
          print(f'|--------|-------|----------|')
          
          # Parse module coverage
          for package in root.findall('.//package'):
              name = package.attrib['name']
              line_rate = float(package.attrib['line-rate']) * 100
              lines_covered = int(package.attrib['lines-covered'])
              lines_valid = int(package.attrib['lines-valid'])
              
              print(f'| {name} | {lines_covered}/{lines_valid} | {line_rate:.1f}% |')
          
          # Load JSON report for detailed analysis
          try:
              with open('coverage.json', 'r') as f:
                  coverage_data = json.load(f)
              
              print(f'')
              print(f'### Files with Low Coverage')
              print(f'')
              
              files = coverage_data.get('files', {})
              low_coverage_files = []
              
              for filepath, data in files.items():
                  coverage_percent = data['summary']['percent_covered']
                  if coverage_percent < ${{ env.COVERAGE_THRESHOLD }}:
                      missing_lines = len(data['missing_lines'])
                      low_coverage_files.append((filepath, coverage_percent, missing_lines))
              
              if low_coverage_files:
                  print(f'| File | Coverage | Missing Lines |')
                  print(f'|------|----------|---------------|')
                  
                  for filepath, coverage_percent, missing_lines in sorted(low_coverage_files, key=lambda x: x[1]):
                      print(f'| {filepath} | {coverage_percent:.1f}% | {missing_lines} |')
              else:
                  print('‚úÖ All files meet coverage threshold!')
          
          except Exception as e:
              print(f'Error processing detailed coverage: {e}')
          " > coverage-summary.md

      - name: Add coverage summary to step summary
        run: |
          cat coverage-summary.md >> $GITHUB_STEP_SUMMARY

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false
          verbose: true

      - name: Upload coverage artifacts
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            coverage.xml
            coverage.json
            htmlcov/
            coverage-badge.svg
            coverage-summary.md
            coverage-junit.xml
          retention-days: 30

      - name: Comment coverage on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Read coverage summary
            let coverageSummary = '';
            try {
              coverageSummary = fs.readFileSync('coverage-summary.md', 'utf8');
            } catch (error) {
              console.log('Could not read coverage summary');
              return;
            }
            
            // Find existing coverage comment
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' && comment.body.includes('Coverage Report Summary')
            );
            
            const commentBody = `## üìä Code Coverage Report
            
            ${coverageSummary}
            
            <details>
            <summary>View detailed coverage report</summary>
            
            You can view the full HTML coverage report in the artifacts of this workflow run.
            
            </details>
            
            ---
            *This comment was automatically generated by the Coverage workflow*
            `;
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody,
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody,
              });
            }

  # Coverage tracking over time
  coverage-tracking:
    name: Coverage Tracking
    runs-on: ubuntu-latest
    needs: coverage-analysis
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download coverage report
        uses: actions/download-artifact@v4
        with:
          name: coverage-report

      - name: Store coverage history
        run: |
          # Create coverage history directory
          mkdir -p .github/coverage-history
          
          # Extract coverage percentage from XML
          python -c "
          import xml.etree.ElementTree as ET
          from datetime import datetime
          import json
          import os
          
          # Parse coverage
          tree = ET.parse('coverage.xml')
          root = tree.getroot()
          line_rate = float(root.attrib['line-rate']) * 100
          
          # Load existing history
          history_file = '.github/coverage-history/coverage.json'
          history = []
          
          if os.path.exists(history_file):
              try:
                  with open(history_file, 'r') as f:
                      history = json.load(f)
              except:
                  history = []
          
          # Add new entry
          entry = {
              'date': datetime.now().isoformat(),
              'commit': '${{ github.sha }}',
              'coverage': round(line_rate, 2)
          }
          
          history.append(entry)
          
          # Keep only last 100 entries
          history = history[-100:]
          
          # Save updated history
          os.makedirs(os.path.dirname(history_file), exist_ok=True)
          with open(history_file, 'w') as f:
              json.dump(history, f, indent=2)
          
          print(f'Coverage: {line_rate:.1f}%')
          print(f'History entries: {len(history)}')
          "

      - name: Commit coverage history
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add .github/coverage-history/coverage.json
          git diff --staged --quiet || git commit -m "Update coverage history [skip ci]"
          git push || echo "No changes to push"